<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Hand Controlled Cube</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Three.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<!-- MediaPipe -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<style>
  body { margin:0; overflow:hidden; background:black; }
  #video { display:none; }
  #hint {
    position:fixed;
    bottom:15px;
    width:100%;
    text-align:center;
    color:white;
    font-family:Arial;
    opacity:0.7;
  }
</style>
</head>
<body>

<video id="video" autoplay playsinline></video>
<div id="hint">
  Move hand: rotate X/Y • Open/close palm: scale
</div>

<script>
/* ======================
   THREE.JS SETUP
====================== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(
  60, window.innerWidth / window.innerHeight, 0.1, 100
);
camera.position.z = 4;

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff, 0.7));
const light = new THREE.DirectionalLight(0xffffff, 0.9);
light.position.set(4,6,3);
scene.add(light);

/* ======================
   CUBE MODEL
====================== */
const cube = new THREE.Mesh(
  new THREE.BoxGeometry(1.5, 1.5, 1.5),
  new THREE.MeshStandardMaterial({
    color: 0x3399ff,
    metalness: 0.2,
    roughness: 0.3
  })
);
scene.add(cube);

/* ======================
   HAND TRACKING
====================== */
const video = document.getElementById("video");

const hands = new Hands({
  locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
});

hands.setOptions({
  maxNumHands: 1,
  modelComplexity: 1,
  minDetectionConfidence: 0.7,
  minTrackingConfidence: 0.7
});

/* Target transforms */
let targetRotX = 0;
let targetRotY = 0;
let targetScale = 1;

/* Utility */
function dist(a,b){
  return Math.hypot(a.x-b.x, a.y-b.y);
}

hands.onResults(results => {
  if (!results.multiHandLandmarks) return;

  const lm = results.multiHandLandmarks[0];

  const wrist = lm[0];
  const indexBase = lm[5];
  const pinkyBase = lm[17];
  const indexTip = lm[8];
  const pinkyTip = lm[20];

  /* ========= ROTATION (HIGH SENSITIVITY) ========= */

  // Horizontal movement → Y rotation
  const dx = indexBase.x - wrist.x;
  targetRotY = dx * Math.PI * 3.5;   // tăng nhạy

  // Vertical movement → X rotation
  const dy = wrist.y - indexBase.y;
  targetRotX = dy * Math.PI * 3.0;   // tăng nhạy

  /* ========= SCALE (MORE RESPONSIVE) ========= */

  const palmWidth = dist(indexBase, pinkyBase);
  const fingerSpread = dist(indexTip, pinkyTip);

  const openness = fingerSpread / palmWidth;
  targetScale = THREE.MathUtils.clamp(
    openness * 1.6,   // scale gain cao hơn
    0.5,
    2.2
  );
});

/* Camera */
const cam = new Camera(video,{
  onFrame: async()=>{ await hands.send({image:video}); },
  width:640,
  height:480
});
cam.start();

/* ======================
   ANIMATION LOOP
====================== */
function animate(){
  requestAnimationFrame(animate);

  // Faster response (less damping)
  cube.rotation.x += (targetRotX - cube.rotation.x) * 0.2;
  cube.rotation.y += (targetRotY - cube.rotation.y) * 0.2;

  const s = cube.scale.x + (targetScale - cube.scale.x) * 0.2;
  cube.scale.set(s, s, s);

  renderer.render(scene, camera);
}
animate();

/* Resize */
window.addEventListener("resize",()=>{
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
