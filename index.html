<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Five-Finger Can Crush</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

<style>
body{margin:0;overflow:hidden;background:#111;}
#track{
  position:fixed;right:12px;bottom:12px;
  width:220px;height:165px;border:2px solid #00ffaa;
}
#video,#overlay{
  position:absolute;width:100%;height:100%;object-fit:cover;
}
</style>
</head>
<body>

<div id="track">
  <video id="video" autoplay playsinline muted></video>
  <canvas id="overlay"></canvas>
</div>

<script>
/* ======================
   THREE SCENE
====================== */
const scene=new THREE.Scene();
scene.background=new THREE.Color(0x111111);

const cam3D=new THREE.PerspectiveCamera(50,innerWidth/innerHeight,0.1,100);
cam3D.position.set(0,1.4,4);

const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff,0.8));

/* ======================
   CAN GEOMETRY (HIGH RES)
====================== */
const R=0.32,H=1.2,RAD=120,HSEG=8;
const geo=new THREE.CylinderGeometry(R,R,H,RAD,HSEG,true);
const mat=new THREE.MeshStandardMaterial({color:0xc41414,side:THREE.DoubleSide});
const can=new THREE.Mesh(geo,mat);
can.position.y=0.6;
scene.add(can);

const pos=geo.attributes.position;
const base=pos.array.slice();

/* Panel memory */
const panelDent=new Float32Array(RAD);
const panelHard=new Float32Array(RAD).map(()=>0.4+Math.random()*0.6);

/* ======================
   MEDIAPIPE HANDS
====================== */
const video=document.getElementById("video");
const canvas=document.getElementById("overlay");
const ctx=canvas.getContext("2d");
canvas.width=220;canvas.height=165;

const hands=new Hands({
  locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
});
hands.setOptions({
  maxNumHands:1,
  modelComplexity:0,
  minDetectionConfidence:0.7,
  minTrackingConfidence:0.7
});

let handVisible=false;
let grip=0,lastGrip=0;
let fingerAngles=[];

function dist(a,b){return Math.hypot(a.x-b.x,a.y-b.y);}

hands.onResults(r=>{
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(video,0,0,canvas.width,canvas.height);

  if(!r.multiHandLandmarks){
    handVisible=false;
    return;
  }
  handVisible=true;
  const lm=r.multiHandLandmarks[0];
  drawConnectors(ctx,lm,HAND_CONNECTIONS,{color:"#00ffaa"});
  drawLandmarks(ctx,lm,{color:"#ff3355"});

  grip=THREE.MathUtils.clamp((0.22-dist(lm[4],lm[20]))/0.15,0,1);

  // 5 fingertips â†’ 5 force vectors
  const tips=[4,8,12,16,20];
  fingerAngles=tips.map(i=>{
    const x=lm[i].x-0.5;
    return (Math.atan2(0,x)+Math.PI)/(2*Math.PI);
  });
});

new Camera(video,{
  onFrame:async()=>{await hands.send({image:video});},
  width:640,height:480
}).start();

/* ======================
   DEFORMATION LOOP
====================== */
function animate(){
  requestAnimationFrame(animate);

  const velocity=Math.abs(grip-lastGrip);
  lastGrip=grip;

  if(handVisible && grip>0.02){
    fingerAngles.forEach(a=>{
      const sector=Math.floor(a*RAD);
      for(let i=-3;i<=3;i++){
        const s=(sector+i+RAD)%RAD;
        const weight=1-Math.abs(i)/3;
        const force=grip*velocity*panelHard[s]*0.05*weight;
        panelDent[s]=Math.min(panelDent[s]+force,0.25);
      }
    });
  }

  for(let i=0;i<pos.count;i++){
    const idx=i*3;
    const x0=base[idx],y0=base[idx+1],z0=base[idx+2];
    const r=Math.hypot(x0,z0);
    if(r<0.001)continue;

    if(Math.abs(y0)>H*0.46){
      pos.array[idx]=x0;
      pos.array[idx+2]=z0;
      continue;
    }

    const ang=(Math.atan2(z0,x0)+Math.PI)/(2*Math.PI);
    const s=Math.floor(ang*RAD)%RAD;

    const nx=x0/r,nz=z0/r;
    pos.array[idx]=nx*(R-panelDent[s]);
    pos.array[idx+2]=nz*(R-panelDent[s]);
  }

  pos.needsUpdate=true;
  renderer.render(scene,cam3D);
}
animate();

addEventListener("resize",()=>{
  cam3D.aspect=innerWidth/innerHeight;
  cam3D.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>

</body>
</html>

