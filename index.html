<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Telekinetic Coke Can</title>
<style>
  body { margin:0; overflow:hidden; background:#111; }
  #debug {
    position:fixed;
    right:10px; bottom:10px;
    width:200px; height:150px;
    border:2px solid #fff;
  }
</style>
</head>
<body>

<video id="video" autoplay playsinline style="display:none"></video>
<canvas id="debug"></canvas>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/* =========================
   THREE.JS SCENE
========================= */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 100);
camera.position.set(0,1.5,4);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.DirectionalLight(0xffffff,1.2));
scene.add(new THREE.AmbientLight(0x555555));

/* =========================
   TABLE
========================= */
const table = new THREE.Mesh(
  new THREE.BoxGeometry(5,0.2,5),
  new THREE.MeshStandardMaterial({color:0x5a3a1a})
);
table.position.y = -1;
scene.add(table);

/* =========================
   CAN GEOMETRY
========================= */
const RAD = 96, H = 40;
const R = 0.35, HEIGHT = 1.2;

const geo = new THREE.CylinderGeometry(
  R, R, HEIGHT, RAD, H, true
);
geo.rotateY(Math.PI / RAD);

const pos = geo.attributes.position;
const basePos = pos.array.slice();

const panelDent = new Float32Array(RAD);
const panelRidge = new Float32Array(RAD);
const panelHard = new Float32Array(RAD).fill(1);

const mat = new THREE.MeshStandardMaterial({
  color:0xc1121f,
  roughness:1,
  metalness:0,
  side:THREE.DoubleSide
});

const can = new THREE.Mesh(geo, mat);
can.position.y = -0.35;
scene.add(can);

/* =========================
   HAND TRACKING
========================= */
let grip = 0, gripVel = 0, lastGrip = 0;
let fingerAngles = [];

const video = document.getElementById("video");
const debug = document.getElementById("debug");
const dctx = debug.getContext("2d");

const hands = new Hands({
  locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
});
hands.setOptions({
  maxNumHands:1,
  modelComplexity:1,
  minDetectionConfidence:0.7,
  minTrackingConfidence:0.7
});

hands.onResults(res=>{
  dctx.clearRect(0,0,debug.width,debug.height);

  if(!res.multiHandLandmarks) return;

  const lm = res.multiHandLandmarks[0];
  dctx.strokeStyle="lime";
  lm.forEach(p=>{
    dctx.beginPath();
    dctx.arc(p.x*debug.width,p.y*debug.height,3,0,Math.PI*2);
    dctx.stroke();
  });

  const palm = lm[0];
  const tips = [4,8,12,16,20];

  let sum = 0;
  fingerAngles = [];

  tips.forEach(i=>{
    const dx = lm[i].x - palm.x;
    const dy = lm[i].y - palm.y;
    const d = Math.hypot(dx,dy);
    sum += d;
    fingerAngles.push((Math.atan2(dx,dy)+Math.PI)/(2*Math.PI));
  });

  grip = THREE.MathUtils.clamp(
    1 - sum / 1.2,
    0, 1
  );
});

new Camera(video,{
  onFrame: async()=>hands.send({image:video}),
  width:640,height:480
}).start();

/* =========================
   DEFORMATION MODEL
   Ratio hand : can = 1 : 2
========================= */
function deform(){
  gripVel = grip - lastGrip;
  lastGrip = grip;

  if(gripVel <= 0) return;

  const FORCE_RATIO = 2.0;

  fingerAngles.forEach(a=>{
    const c = Math.floor(a * RAD);
    for(let i=-4;i<=4;i++){
      const s = (c+i+RAD)%RAD;
      const w = 1 - Math.abs(i)/4;
      const f = gripVel * FORCE_RATIO * w * panelHard[s];

      panelDent[s] = Math.min(panelDent[s] + f, 0.35);
      if(Math.abs(i)===2) panelRidge[s] += f*0.6;
      panelHard[s] *= 0.985;
    }
  });

  for(let i=0;i<pos.count;i++){
    const y = basePos[i*3+1];
    if(Math.abs(y) > HEIGHT*0.45){
      pos.array[i*3]   = basePos[i*3];
      pos.array[i*3+1] = basePos[i*3+1];
      pos.array[i*3+2] = basePos[i*3+2];
      continue;
    }

    const x = basePos[i*3], z = basePos[i*3+2];
    const ang = (Math.atan2(x,z)+Math.PI)/(2*Math.PI);
    const s = Math.floor(ang*RAD)%RAD;

    const dent = panelDent[s];
    const ridge = panelRidge[s];

    const nx = x / R, nz = z / R;
    const radial = R - dent;
    const ridgePush = ridge * Math.sign(Math.sin(ang*Math.PI*2));

    pos.array[i*3]   = nx*radial + nz*ridgePush;
    pos.array[i*3+2] = nz*radial - nx*ridgePush;
  }

  pos.needsUpdate = true;
}

/* =========================
   LOOP
========================= */
function animate(){
  requestAnimationFrame(animate);
  deform();
  can.rotation.y += 0.002;
  renderer.render(scene,camera);
}
animate();

addEventListener("resize",()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>

